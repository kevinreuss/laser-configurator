<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Laser Configurator</title>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      .container {
        display: flex;
        gap: 20px;
        margin: 20px;
      }
      #map {
        height: 500px;
        width: 50%;
      }
      #svg-preview {
        height: 500px;
        width: 50%;
        border: 1px solid #ccc;
      }
      .controls {
        margin: 20px;
      }
      .search-container {
        margin-bottom: 10px;
      }
      #searchResults {
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        max-height: 200px;
        overflow-y: auto;
        width: 300px;
        display: none;
      }
      #searchResults div {
        padding: 5px 10px;
        cursor: pointer;
      }
      #searchResults div:hover {
        background-color: #f0f0f0;
      }
    </style>
  </head>
  <body>
    <h1>Laser Configurator</h1>
    <div class="controls">
      <div class="search-container">
        <input
          type="text"
          id="searchInput"
          placeholder="Ort suchen..."
          style="width: 300px"
        />
        <div id="searchResults"></div>
      </div>
      <button onclick="goToLocation('Alexanderplatz, Berlin')">
        Alexanderplatz Berlin
      </button>
      <button onclick="goToLocation('Brandenburger Tor, Berlin')">
        Brandenburger Tor
      </button>
      <button onclick="goToLocation('Kölner Dom')">Kölner Dom</button>
      <button onclick="goToLocation('Hamburger Hafen')">Hamburger Hafen</button>
      <button onclick="goToLocation('Münchner Marienplatz')">
        Münchner Marienplatz
      </button>
    </div>
    <div class="container">
      <div id="map"></div>
      <div id="svg-preview"></div>
    </div>

    <script>
      // Initialize map centered on Alexanderplatz
      const map = L.map("map").setView([52.5219, 13.4132], 15); // Alexanderplatz coordinates
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
      }).addTo(map);

      // Search functionality
      const searchInput = document.getElementById("searchInput");
      const searchResults = document.getElementById("searchResults");
      let searchTimeout;

      searchInput.addEventListener("input", function () {
        clearTimeout(searchTimeout);
        if (this.value.length < 3) {
          searchResults.style.display = "none";
          return;
        }

        searchTimeout = setTimeout(() => {
          fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
              this.value
            )}`
          )
            .then((response) => response.json())
            .then((data) => {
              searchResults.innerHTML = "";
              data.slice(0, 5).forEach((result) => {
                const div = document.createElement("div");
                div.textContent = result.display_name;
                div.onclick = () => {
                  map.setView([result.lat, result.lon], 15);
                  searchResults.style.display = "none";
                  searchInput.value = result.display_name;
                };
                searchResults.appendChild(div);
              });
              searchResults.style.display = data.length ? "block" : "none";
            });
        }, 300);
      });

      // Hide search results when clicking outside
      document.addEventListener("click", function (e) {
        if (!searchResults.contains(e.target) && e.target !== searchInput) {
          searchResults.style.display = "none";
        }
      });

      // Function to go to predefined locations
      function goToLocation(searchQuery) {
        fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
            searchQuery
          )}`
        )
          .then((response) => response.json())
          .then((data) => {
            if (data.length > 0) {
              map.setView([data[0].lat, data[0].lon], 15);
            }
          });
      }

      // Funktion zum Generieren der SVG
      function generateSVG() {
        const bounds = map.getBounds();

        // Updated query to include roads, railways and waterways
        const query = `
          [out:json][bbox:${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}];
          (
            way["highway"]["highway"!~"footway|path|cycleway|service|track"];
            way["railway"];
            way["waterway"];
          );
          out body;
          >;
          out skel qt;
        `;

        fetch(
          `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(
            query
          )}`
        )
          .then((response) => response.json())
          .then((data) => {
            const ways = data.elements.filter((el) => el.type === "way");
            const nodes = Object.fromEntries(
              data.elements
                .filter((el) => el.type === "node")
                .map((node) => [node.id, { lat: node.lat, lon: node.lon }])
            );

            const visibleBounds = map.getBounds();
            const svgWidth = 500;
            const svgHeight = 500;

            const scaleX = (lon) =>
              ((lon - visibleBounds.getWest()) /
                (visibleBounds.getEast() - visibleBounds.getWest())) *
              svgWidth;
            const scaleY = (lat) =>
              svgHeight -
              ((lat - visibleBounds.getSouth()) /
                (visibleBounds.getNorth() - visibleBounds.getSouth())) *
                svgHeight;

            // Generate SVG paths with clipping
            let svgContent = "";
            ways.forEach((way) => {
              const points = [];
              let lastPoint = null;

              way.nodes.forEach((id) => {
                const node = nodes[id];

                // Check if the node is within bounds
                const isInBounds =
                  node.lat <= visibleBounds.getNorth() &&
                  node.lat >= visibleBounds.getSouth() &&
                  node.lon <= visibleBounds.getEast() &&
                  node.lon >= visibleBounds.getWest();

                if (isInBounds) {
                  points.push(`${scaleX(node.lon)},${scaleY(node.lat)}`);
                  lastPoint = node;
                } else if (lastPoint) {
                  // Add the point and reset lastPoint to create a break in the line
                  points.push(`${scaleX(node.lon)},${scaleY(node.lat)}`);
                  lastPoint = null;
                }
              });

              let lineWidth = "2.5";

              if (points.length > 0) {
                let color = "#000000";
                let width = lineWidth;
                if (way.tags.railway) {
                  color = "#ff0000";
                  width = lineWidth;
                } else if (way.tags.waterway) {
                  color = "#0000ff";
                  width = lineWidth;
                }

                // Create separate polylines for each continuous segment
                const segments = [];
                let currentSegment = [];

                points.forEach((point) => {
                  const [x, y] = point.split(",").map(Number);
                  if (x >= 0 && x <= svgWidth && y >= 0 && y <= svgHeight) {
                    currentSegment.push(point);
                  } else if (currentSegment.length > 0) {
                    segments.push(currentSegment);
                    currentSegment = [];
                  }
                });

                if (currentSegment.length > 0) {
                  segments.push(currentSegment);
                }

                // Draw each segment
                segments.forEach((segment) => {
                  if (segment.length > 1) {
                    svgContent += `<polyline points="${segment.join(
                      " "
                    )}" stroke="${color}" stroke-width="${width}" fill="none"/>`;
                  }
                });
              }
            });

            // Complete SVG
            const finalSvg = `
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
                ${svgContent}
              </svg>
            `;

            const svgPreview = document.getElementById("svg-preview");
            svgPreview.innerHTML = finalSvg;
          });
      }

      // Event Listener für Kartenänderungen
      map.on("moveend", generateSVG);
      map.on("zoomend", generateSVG);

      // Initial generieren
      generateSVG();
    </script>
  </body>
</html>
