<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Laser Configurator</title>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      .container {
        display: flex;
        gap: 20px;
        margin: 20px;
      }
      #map {
        height: 500px;
        width: 50%;
      }
      #svg-preview {
        height: 500px;
        width: 50%;
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <h1>Laser Configurator</h1>
    <div class="container">
      <div id="map"></div>
      <div id="svg-preview"></div>
    </div>

    <script>
      // Initialisiere die Karte
      const map = L.map("map").setView([51.1657, 10.4515], 13); // Startet in Deutschland
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
      }).addTo(map);

      // Funktion zum Generieren der SVG
      function generateSVG() {
        const bounds = map.getBounds();

        // Updated query to include roads, railways and waterways
        const query = `
          [out:json][bbox:${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}];
          (
            way["highway"]["highway"!~"footway|path|cycleway|service|track"];
            way["railway"];
            way["waterway"];
          );
          out body;
          >;
          out skel qt;
        `;

        fetch(
          `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(
            query
          )}`
        )
          .then((response) => response.json())
          .then((data) => {
            const ways = data.elements.filter((el) => el.type === "way");
            const nodes = Object.fromEntries(
              data.elements
                .filter((el) => el.type === "node")
                .map((node) => [node.id, { lat: node.lat, lon: node.lon }])
            );

            const visibleBounds = map.getBounds();
            const svgWidth = 500;
            const svgHeight = 500;

            const scaleX = (lon) =>
              ((lon - visibleBounds.getWest()) /
                (visibleBounds.getEast() - visibleBounds.getWest())) *
              svgWidth;
            const scaleY = (lat) =>
              svgHeight -
              ((lat - visibleBounds.getSouth()) /
                (visibleBounds.getNorth() - visibleBounds.getSouth())) *
                svgHeight;

            // Generate SVG paths with clipping
            let svgContent = "";
            ways.forEach((way) => {
              const points = [];
              let lastPoint = null;

              way.nodes.forEach((id) => {
                const node = nodes[id];

                // Check if the node is within bounds
                const isInBounds =
                  node.lat <= visibleBounds.getNorth() &&
                  node.lat >= visibleBounds.getSouth() &&
                  node.lon <= visibleBounds.getEast() &&
                  node.lon >= visibleBounds.getWest();

                if (isInBounds) {
                  points.push(`${scaleX(node.lon)},${scaleY(node.lat)}`);
                  lastPoint = node;
                } else if (lastPoint) {
                  // Add the point and reset lastPoint to create a break in the line
                  points.push(`${scaleX(node.lon)},${scaleY(node.lat)}`);
                  lastPoint = null;
                }
              });

              if (points.length > 0) {
                let color = "black";
                let width = "0.5";
                if (way.tags.railway) {
                  color = "#666";
                  width = "0.8";
                } else if (way.tags.waterway) {
                  color = "#0077be";
                  width = "1";
                }

                // Create separate polylines for each continuous segment
                const segments = [];
                let currentSegment = [];

                points.forEach((point) => {
                  const [x, y] = point.split(",").map(Number);
                  if (x >= 0 && x <= svgWidth && y >= 0 && y <= svgHeight) {
                    currentSegment.push(point);
                  } else if (currentSegment.length > 0) {
                    segments.push(currentSegment);
                    currentSegment = [];
                  }
                });

                if (currentSegment.length > 0) {
                  segments.push(currentSegment);
                }

                // Draw each segment
                segments.forEach((segment) => {
                  if (segment.length > 1) {
                    svgContent += `<polyline points="${segment.join(
                      " "
                    )}" stroke="${color}" stroke-width="${width}" fill="none"/>`;
                  }
                });
              }
            });

            // Complete SVG
            const finalSvg = `
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}" width="100%" height="100%">
                ${svgContent}
              </svg>
            `;

            const svgPreview = document.getElementById("svg-preview");
            svgPreview.innerHTML = finalSvg;
          });
      }

      // Event Listener für Kartenänderungen
      map.on("moveend", generateSVG);
      map.on("zoomend", generateSVG);

      // Initial generieren
      generateSVG();
    </script>
  </body>
</html>
